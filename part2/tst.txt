/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;
import java.io.FileWriter;
import java.io.IOException;


/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    void print(String s) //prints a string
    {
        System.out.println(s);
    }

    void produceOutputFile(String s, String fname) throws IOException
    //prints s in a new file named fname
    {
        FileWriter writer = new FileWriter(fname);
        writer.write(s);
        writer.close();
    }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            ENTER, CONCAT, PREFIX, SUFFIX, IF, ELSE, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA;
terminal String     STRING_LITERAL, ID;

/*  Non terminals */
non terminal            start_prog;
non terminal String     expr, plain_expr, expr_list, logic_expr, if_expr, funct_decl, argument, main_prog;
non terminal String     argu_list, funct_call, func_expr_list, components, decl_argu_list;      // used to store evaluated subexpressions

/**
 *  Precedence Declarations
 */

precedence left LPAREN;
precedence left CONCAT, PREFIX, SUFFIX;
precedence left IF;
precedence left ID;


/**
 *  The Grammar Rules
 */

//program starts with declaration of functions and then the main function from the user, but prints them backwards
start_prog ::= components:c   {:
                  print(String.format("\n\npublic class Main {\n%s\n}", c));
                  produceOutputFile(String.format("public class Main {\n\t%s\n}", c), "Main.java");
                  :}
             ;

components ::= funct_decl:f components:rest  {: RESULT = String.format("\t%s\n\t%s", f, rest);   :}
              | main_prog:main               {: RESULT = String.format("\t%s", main);            :}
             ;

main_prog  ::= expr:e main_prog:m {:
			    RESULT = String.format("public static void main(String[] args) {\n%s\t}\n", e);
			    :}
			   | expr:e {:RESULT = (String.format("%s",e);:}
	         ;

expr_list  ::= expr_list:rest expr:e         {: RESULT = String.format("%s\t\tSystem.out.println(%s);\n", rest, e);  :}
              |                              {: RESULT = "";                                     :}
             ;

expr       ::= expr:e1 CONCAT  expr:e2       {: RESULT = String.format("%s + %s", e1, e2);       :}
              | expr:e1 PREFIX expr:e2       {: RESULT = String.format("%s.prefixOf(%s)", e1, e2);  :}
              | expr:e1 SUFFIX expr:e2       {: RESULT = String.format("%s.suffixOf(%s)", e1, e2);  :}
              | if_expr:ie                   {: RESULT = String.format("%s", ie);                :}
              | LPAREN expr:e RPAREN         {: RESULT = String.format("(%s)", e);               :}
              | funct_call:fc                {: RESULT = String.format("%s", fc);                :}
              | ID:id                        {: RESULT = String.format("%s", id);                :}
              | STRING_LITERAL:s             {: RESULT = String.format("\"%s\"", s);             :}
             ;

logic_expr ::= expr:e1 PREFIX expr:e2        {: RESULT = String.format("%s.startsWith(%s)", e1, e2); :}
              | expr:e1 SUFFIX expr:e2       {: RESULT = String.format("%s.endsWith(%s)", e1, e2); :}
             ;

if_expr    ::= IF LPAREN logic_expr:le RPAREN expr:e1 ELSE expr:e2
                    {: RESULT = String.format("%s ? %s : %s", le, e1, e2);:}
             ;

funct_decl ::= ID:id LPAREN decl_argu_list:args RPAREN LBRACKET func_expr_list:e RBRACKET    {:
                RESULT = String.format("public static String %s(%s) {\n %s\t}", id, args, e);
                :}
             ;

funct_call ::= ID:id LPAREN argu_list:args RPAREN    {:
                RESULT = String.format("%s(%s)", id, args);
                :}
             ;

func_expr_list ::= expr_list:rest expr:e {: RESULT = String.format("%s\t\treturn %s;\n", rest, e);  :}
              |                              {: RESULT = "";                                     :}
             ;

//arguments for calls. can be any expr
argu_list  ::= expr:e                        {: RESULT = String.format("%s", e);                 :} //single
              | argu_list:rest COMMA expr:e  {: RESULT = String.format("%s, %s", rest, e);    :} //multiple
              |                              {: RESULT = "";                                     :} //none
             ;

//arguments for declarations. include identifiers only
decl_argu_list ::= ID:id                     {: RESULT = String.format("%s", id);                 :} //single
              | decl_argu_list:rest COMMA ID:id {: RESULT = String.format("%s, %s", rest, id);      :} //multiple
              |                              {: RESULT = "";                                     :} //none
             ;

//arguments for calls. can include ids, strings, other calls or +
argument ::= ID:id                           {: RESULT = String.format("%s", id);                :}
              | STRING_LITERAL:s             {: RESULT = String.format("\"%s\"", s);             :}
              | funct_call:fc                {: RESULT = String.format("%s", fc);                :}
              | expr:e1 CONCAT  expr:e2      {: RESULT = String.format("%s + %s", e1, e2);       :}
             ;

/**
op         ::= CONCAT

logical_op ::= PREFIX
              | SUFFIX

             */